#include <mysql.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <pthread.h>
	
	typedef struct{
	int socket;
	int num;
}Parametres; //Ens servira per a saber el nombre d'elements connectats i passar el socket al thread.
typedef struct{
	int ataque;
	//int probError;
	int tipo;
}Movimiento; //Movimientos Pokemon i els seus atributs, utilitzats per calcular el mal
typedef struct{
	int ataque;
	int vida;
	int tipo; 
	int defensa;
	int velocidad;
	int id;
	char nombre[20];
	Movimiento movimientos[4];
}Pokemon; //Definicio de pokemon i les seves caracteristiques propies
typedef struct{
	int socket;
	char nombre[20];
}CConectado; //Futur element de la lista de conectados
typedef struct{
	int longitud;
	CConectado usuarios[100];
}ListaConectado; 
typedef struct{
	int socket;
	Pokemon pokemonLuchador; //ID del Pokemon
	Pokemon pokemon[3]; //IDs
	//Guarda la voluntat del jugador per fer el que sigui quan li toqui
	int nextAction;
	int nextPokemon;
	int nextMovement;
	int muerto;
	int nextObjective;
}Jugador; //Jugador dins una partida.
typedef struct{
	int jugadores;
	int pokemonsTriats;
	int turnoReady;
	int pendientes;//Pendientes de contestar
	Jugador identidad[4];
}CPartida; //Partida i les seves característiques
typedef struct{
	int numero;
	CPartida partida[100];
}ListaPartida; //lista de partides, màxim 100.

Pokemon listaPokemon[12];
Movimiento listaMovimientos[35];
ListaConectado lista;
ListaPartida Partidas;
MYSQL *conn;
pthread_mutex_t accesoexcluyente;

void Afegirvictoria(char nombre[32], MYSQL *conn)//Suma 1 a las victorias del usuario nombre.
{
	//piden registrarse
	//separamos el username y la contrasena
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	char buff2[256];
	int numero,i=0;
	char consulta [80];
	int IDUs, err;
	// construimos la consulta SQL
	//buscamos el ultimo ID asignado a un usuario
	sprintf(consulta,"UPDATE Usuarios SET Victorias = Victorias +1 WHERE Usuarios.Username = '%s'",nombre);
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		strcpy (buff2,"1/0,");
	}
}
void cargar_pokemons(MYSQL *conn,Pokemon Pokemons[11])//Carga los pokemons de la DB
{
	
	//LLEGIR QUERYS
	// Estructura especial para almacenar resultados de consultas 
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	int numero,i=0;
	char consulta [80];
	int err;
	
	// construimos la consulta SQL
	strcpy (consulta,"SELECT* FROM Pokemons;"); 
	// hacemos la consulta 
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		exit(1);
	}
	//recogemos el resultado de la consulta resultado = mysql_store_result (conn); 
	resultado = mysql_store_result (conn);
	numero=  mysql_num_rows(resultado);
	row = mysql_fetch_row (resultado);
	if (row == NULL)
	{
		printf ("No se han obtenido datos en la consulta\n");
	}
	else
	{
		while(i<numero)
		{
			//Muestro por pantalla para comporobar que carga los pokemons
			//printf("%s, %s, %s, %s\n",row[0],row[1],row[2],row[3]);
			Pokemons[i].id = atoi(row[0]);
			Pokemons[i].tipo = atoi(row[0]);
			Pokemons[i].vida=atoi(row[1]);
			strcpy(Pokemons[i].nombre,row[2]);
			Pokemons[i].ataque=atoi(row[3]);
			Pokemons[i].defensa=atoi(row[4]);
			Pokemons[i].velocidad=atoi(row[5]);
			row = mysql_fetch_row (resultado);
			i++;
		}
		row = mysql_fetch_row (resultado);
		row = mysql_fetch_row (resultado);
	}
	printf("Pokemons cargados\n");
}
void cargar_movimientos(MYSQL *conn,Movimiento Movimientos[32])//Carga los movimientos pokemon y sus atributos de la DB
{
	
	//LLEGIR QUERYS
	// Estructura especial para almacenar resultados de consultas 
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	int numero,i=0;
	char consulta [80];
	int err;
	
	strcpy (consulta,"SELECT* FROM Movements;"); 
	// hacemos la consulta 
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		exit(1);
	}
	//recogemos el resultado de la consulta resultado = mysql_store_result (conn); 
	resultado = mysql_store_result (conn);
	numero=  mysql_num_rows(resultado);
	row = mysql_fetch_row (resultado);
	if (row == NULL)
	{
		printf ("No se han obtenido datos en la consulta\n");
	}
	else
	{
		while(i<numero)
		{
			Movimientos[i].ataque=atoi(row[2]);
			Movimientos[i].tipo=atoi(row[3]);
			i++;
			row = mysql_fetch_row (resultado);
		}
	}
	printf("Movimientos cargados\n");
}
float CalcularDanyo(int pokemonAtaca, int atac, int pokemonDefensa) //Es calcula el mal entre pokemons tenint en compte tipus, atributs del moviment i defensa del pokemon enemic
{
	int a,p,d,v;
	v = rand() % 16 + 85;
	float b, e, mal;
	a = listaPokemon[pokemonAtaca].ataque;
	p = listaMovimientos[atac].ataque;
	d = listaPokemon[pokemonDefensa].defensa;
	b = 1;
	if(listaPokemon[pokemonAtaca].tipo == listaMovimientos[atac].tipo)
		b = 1.5;
	switch( listaMovimientos[atac].tipo )   
	{  
	case 1:  //Psycko
		if(listaPokemon[pokemonDefensa].tipo == 6) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 1) //No eficaz
			e = 0.5;
		break;
		
	case 2: //Agua
		if(listaPokemon[pokemonDefensa].tipo == 3) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 5) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 7) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 2) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 10) //No eficaz	
			e = 0.5;
		break;
		
	case 3:  //Fuego
		if(listaPokemon[pokemonDefensa].tipo == 10) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 12) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 4) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 2) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 3) //No eficaz	
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 5) //No eficaz
			e = 0.5;
		break;
	case 4: //Ice
		if(listaPokemon[pokemonDefensa].tipo == 10) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 7) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 8) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 2) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 3) //No eficaz	
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 4) //No eficaz
			e = 0.5;
		break;
	case 5:  //Rock
		if(listaPokemon[pokemonDefensa].tipo == 3) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 12) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 4) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 6) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 7) //No eficaz	
			e = 0.5;
		break;
		
		
	case 6: //Fight
		if(listaPokemon[pokemonDefensa].tipo == 5) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 11) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 4) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 1) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 8) //No eficaz
			e = 0.5;
		break;
		
	case 7:  //Tierra
		if(listaPokemon[pokemonDefensa].tipo == 9) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 3) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 2) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 12) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 10) //No eficaz
			e = 0.5;
		break;
		
	case 8: //Fly
		if(listaPokemon[pokemonDefensa].tipo == 6) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 12) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 10) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 9) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 5) //No eficaz
			e = 0.5;
		break;
		
	case 9: //Ellectric
		if(listaPokemon[pokemonDefensa].tipo == 2) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 8) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 9) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 10) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 7) //No AFECTA
			e = 0;
		break;
	case 10: //Planta
		if(listaPokemon[pokemonDefensa].tipo == 2) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 7) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 5) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 12) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 3) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 10) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 8) //No eficaz
			e = 0.5;
		break;	
	case 11: //Dark
		if(listaPokemon[pokemonDefensa].tipo == 1) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 6) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 11) //No eficaz	
			e = 0.5;
		break;
	case 12: //BICHO
		if(listaPokemon[pokemonDefensa].tipo == 10) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 1) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 11) //Muy eficaz
			e = 2;
		if(listaPokemon[pokemonDefensa].tipo == 3) //No eficaz
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 6) //No eficaz	
			e = 0.5;
		if(listaPokemon[pokemonDefensa].tipo == 8) //No eficaz
			e = 0.5;
		break;
	default: 
		e = 1;
		break;
	}
	if(e!=1 && e!=0.5 && e!=0)
	{
		e=1;
	}
	mal = 0.1*b*e*v*((a*p)/(4*d) + 2);
	return mal;
	
}
int BuscarJugador(int idPart, int socket, ListaPartida *Partidas) //Torna la posicio d'un socket dins una partida.
{
	int encontrado = 0;
	int i=0;
	while(!encontrado && i<4)
	{
		if(Partidas->partida[idPart].identidad[i].socket == socket)
			encontrado = 1;
		else
			i++;
	}
	return i;
}
void BuscarConectado(char nom[32], int socket, ListaConectado *lista) //Torna la posicio d'un socket dins la llista de connectats
{
	int encontrado = 0;
	int i=0;
	while(!encontrado && i<lista->longitud)
	{
		if(lista->usuarios[i].socket == socket)
			encontrado = 1;
		else
			i++;
	}
	strcpy(nom, lista->usuarios[i].nombre);
}
int BuscarPokemon(int idPokemon, Pokemon listaPokemon[16]) //Retorna la posicio d'un id pokemon dins la llista
{
	int encontrado = 0;
	int i=0;
	while(!encontrado && i<16)
	{
		if(listaPokemon[i].id == idPokemon)
			encontrado = 1;
		else
			i++;
	}
	return i;
}
int Crearpartida(int num, int sockets[20], int socket_host,ListaPartida *Partidas)//Transmite las invitaciones y establece los primeros valores del juego.
{
	//De momento almacenamos los datos de los invitados, y el socket del host
	int id = Partidas->numero;
	if(id==100)
	{
		return -1;
	}
	Partidas->partida[id].jugadores=1;
	Partidas->partida[id].pokemonsTriats = 0;
	Partidas->partida[id].turnoReady=0;
	Partidas->partida[id].pendientes=num;
	Partidas->partida[id].identidad[0].socket=socket_host;
	Partidas->numero++;
	char invitacion[512];
	sprintf(invitacion,"30/%d,%d",id,socket_host);
	int i;
	for(i=0;i<num;i++)
	{
		write(sockets[i],invitacion,strlen(invitacion));
	}
	return 0;
}

int RespuestaInvitacion(int IdPart,int respuesta,int socket,ListaPartida *Partidas)//Analiza la respuesta de una invitacion y si todos han contestado se inicia la partida.
{
	int res=-1;
	Partidas->partida[IdPart].pendientes--;
	if(respuesta==1)//Se une
	{
		Partidas->partida[IdPart].identidad[Partidas->partida[IdPart].jugadores].socket=socket;
		Partidas->partida[IdPart].jugadores++;
	}
	//Comprobamos si han contestado todos
	char mensaje[512];
	char text[64];
	if(Partidas->partida[IdPart].pendientes==0)
	{
		sprintf(mensaje,"31/%d,",IdPart);
		if(Partidas->partida[IdPart].jugadores>1)//Enviamos que empieza la partida
		{
			sprintf(text,"1,%d",Partidas->partida[IdPart].jugadores); //ENVIAR MENSAJE ELEGIR POKEMON
			strcat(mensaje,text);
			int i;
			for(i=0;i<Partidas->partida[IdPart].jugadores;i++)
			{
				sprintf(text,",%d",Partidas->partida[IdPart].identidad[i].socket);
				strcat(mensaje,text);
			}
			res=0;
		}
		else
		{
			strcat(mensaje,"0"); //NO ELEGIR POKEMON
			res=-1;
		}
		int i;
		for(i=0;i<Partidas->partida[IdPart].jugadores;i++)
		{
			write(Partidas->partida[IdPart].identidad[i].socket,mensaje,strlen(mensaje));
		}
		return res;
	}
}

void EnviarMensaje(int IdPart,char text[200],ListaPartida *Partidas)//Enviar el mensaje a todos los jugadores de la partida
{
	char mensaje[512];
	sprintf(mensaje,"32/%d,%s",IdPart,text);
	int i;
	for(i=0;i<Partidas->partida[IdPart].jugadores;i++)
	{
		write(Partidas->partida[IdPart].identidad[i].socket,mensaje,strlen(mensaje));
	}
	
}
void JugadorDesconectado(int IdPart,int socket,ListaPartida *Partidas)//Quita el jugador de la partida y lo comunica
{
	int encontrado=0; int i = 0;
	while(encontrado==0 && i<Partidas->partida[IdPart].jugadores)
	{
		if(Partidas->partida[IdPart].identidad[i].socket==socket)
			encontrado=1;
		else i++;
	}
	if(encontrado==1)
	{
		int j;
		for(j=i;(j<Partidas->partida[IdPart].jugadores-1);j++)
		{
			Partidas->partida[IdPart].identidad[j].socket=Partidas->partida[IdPart].identidad[j+1].socket;
		}
		Partidas->partida[IdPart].jugadores--;
		Partidas->partida[IdPart].identidad[Partidas->partida[IdPart].jugadores].socket=0;
	}
	
}

int registro(char nombre[20], char contrasena[20], MYSQL *conn, char respuesta[512])//Devuelve 0 si todo correcto, -1 si hay error. Se registra un nuevo usuario a la base de datos.
{
	//piden registrarse
	//separamos el username y la contrasena
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	char buff2[256];
	int numero,i=0;
	char consulta [80];
	int IDUs, err;
	// construimos la consulta SQL
	
	//buscamos el ultimo ID asignado a un usuario
	strcpy (consulta,"SELECT MAX(Usuarios.IdUs) FROM Usuarios");
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		strcpy (buff2,"1/0,");
		return -1;
	}
	else{
		//recogemos el resultado de la consulta resultado = mysql_store_result (conn); 
		resultado = mysql_store_result (conn);
		numero=mysql_num_rows(resultado);
		row = mysql_fetch_row (resultado);
		if (row == NULL)
		{
			printf ("No se ha obtenido ningun ID\n");
			IDUs=0;
		}
		else
		{
			IDUs=atoi(row[0])+1;//Le sumamos 1 al ultimo ID asignado para conseguir el del nuevo usuario
		}
	}
	sprintf (consulta,"INSERT INTO Usuarios(Username,Password,Victorias,IDUs) VALUES ('%s','%s',0,%d)",nombre,contrasena,IDUs);
	// hacemos la consulta 
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		strcpy (respuesta,"1/1,");
		return -1;
	}
	else
	{
		strcpy (respuesta,"1/0,");
		return 0;
	}
}
int AnadirConectado(int sock_conn,char nombre[20],ListaConectado *lista)//devuelve 0 si todo OK y -1 si la lista de conectados esta llena
{
	
	if (lista->longitud>100)
		return -1;
	else{
		strcpy(lista->usuarios[lista->longitud].nombre,nombre);
		lista->usuarios[lista->longitud].socket=sock_conn;
		lista->longitud=lista->longitud+1;
		return 0;
	}
}
int EliminarConectado(int sock_conn,ListaConectado *lista)//Devuelve 0 si todo correcto, -1 si no lo ha encontrado
{
	int i=0,encontrado=0;
	while((i<lista->longitud)&&(encontrado==0)){
		if (lista->usuarios[i].socket==sock_conn)
			encontrado=1;
		else
			i=i+1;
	}
	if (i>=lista->longitud)
		return -1;
	else{
		while (i<(lista->longitud-1)){
			strcpy(lista->usuarios[i].nombre,lista->usuarios[i+1].nombre);
			lista->usuarios[i].socket=lista->usuarios[i+1].socket;
			i++;
		}
		lista->longitud=lista->longitud-1;
		return 0;
	}
}
void EnviarNotificacion(ListaConectado *lista)//Envia la notificacion cada vez que se produzca conectado/desconectado
{
	char respuesta[512];
	int i=0;
	while(i<lista->longitud){
		int j=0,lon;
		lon=lista->longitud-1;
		sprintf(respuesta,"10/%d,",lon);
		while(j<lista->longitud){
			if (j!=i)
			{
				sprintf(respuesta,"%s%d",respuesta,lista->usuarios[j].socket);
				strcat(respuesta," ");
				strcat(respuesta,lista->usuarios[j].nombre);
				strcat(respuesta,",");
			}
			j=j+1;
		}
		write(lista->usuarios[i].socket,respuesta,strlen(respuesta));
		i=i+1;
	}
	
}
int login(char nombre[20],char contrasena[20],MYSQL *conn)//devuelve un 0 si todo correcto y un 1 si hay error. Comprueba la existencia de las credenciales en la DB.
{
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	int err,numero;
	char consulta [80];
	sprintf(consulta,"SELECT Username FROM Usuarios WHERE Username='%s' AND Password='%s'",nombre,contrasena);
	// hacemos la consulta 
	err=mysql_query(conn, consulta); 
	if (err!=0) 
	{
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		return 1; 
	}
	resultado = mysql_store_result (conn);
	numero=mysql_num_rows(resultado);
	row = mysql_fetch_row (resultado);
	if (row == NULL)
	{
		printf ("No se ha encontrado el usuario\n");
		return 1;
	}
	else
	{
		printf ("Usuario %s encontrado.\n", row[0] );
		return 0;
	}
}

void frase_jordi(MYSQL *conn,char respuesta[512]) //Consulta 1, comprueba si alguien ha ganado en tal fecha
{
	// Estructura especial para almacenar resultados de consultas 
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	int numero,i=0, err;
	char buff2[128]="";
	char nombres[64];
	char consulta [80];
	
	printf("Conexion Establecida\n");
	
	// construimos la consulta SQL
	strcpy (consulta,"SELECT Username FROM Usuarios,Partidas,Resultados WHERE Partidas.FechayHora LIKE '25/07/2017' AND Resultados.IdPart=Partidas.IdPart AND Usuarios.IdUs=Resultados.IdUs AND Usuarios.IdUs=Partidas.IdGanador;"); 
	// hacemos la consulta 
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		exit (1);
	}
	//recogemos el resultado de la consulta resultado = mysql_store_result (conn); 
	resultado = mysql_store_result (conn);
	numero=mysql_num_rows(resultado);
	row = mysql_fetch_row (resultado);
	if (row == NULL)
	{
		printf ("No se han obtenido datos en la consulta\n");
		strcpy(respuesta,"3/3/0");
	}
	else
	{
		sprintf(nombres,"3/3/");
		while(i<numero)
		{
			printf("%s ",row[0]);
			strcat(nombres,strcat(row[0],", "));
			row = mysql_fetch_row (resultado);
			i++;
		}
		strcpy(respuesta,nombres);
	}
}

void frase_gabri(MYSQL *conn,char fecha[80], char respuesta[512]) //Consulta 2
{
	
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	char buff2[128]="";
	int numero=0,i=0;
	char consulta [128];
	int err;
	printf ("Consulta 2 con fecha %s \n",fecha);
	sprintf (consulta,"SELECT Usuarios.Victorias FROM Usuarios,Partidas WHERE Partidas.FechayHora LIKE '%s' AND Partidas.IdGanador=Usuarios.IdUs;",fecha);
	err=mysql_query (conn, consulta); 
	if (err!=0) 
	{
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		
	}
	resultado = mysql_store_result (conn);
	numero=mysql_num_rows(resultado);
	row = mysql_fetch_row (resultado);
	strcpy(buff2,"3/2/");
	if (row == NULL)
	{
		printf ("No se han obtenido datos en la consulta\n");
		strcat (buff2,"0 resultados");
	}
	else
	{
		char src[50], dest[500];
		while(i<numero)
		{
			strcat(buff2, strcat(row[0],", "));								
			row = mysql_fetch_row (resultado);
			i++;
		}
	}
	strcpy(respuesta,buff2);
}

void frase_marc(MYSQL *conn,char respuesta[512]) //Consulta 3 a la DB
{
	//LLEGIR QUERYS
	// Estructura especial para almacenar resultados de consultas 
	MYSQL_RES *resultado;
	MYSQL_ROW row;
	int numero,i=0;
	char consulta [80];
	char nombre[80];
	int err;
	
	printf("Conexion Establecida\n");
	
	// construimos la consulta SQL
	strcpy (consulta,"SELECT Usuarios.Username FROM Usuarios,Partidas WHERE Usuarios.IdUs=Partidas.IdGanador AND Partidas.Duracion=(SELECT MAX(Duracion) FROM Partidas);"); 
	// hacemos la consulta 
	err=mysql_query (conn, consulta); 
	if (err!=0) {
		printf ("Error al consultar datos de la base %u %s\n",
				mysql_errno(conn), mysql_error(conn));
		strcpy (nombre,"Error.");
		exit(1);
	}
	//recogemos el resultado de la consulta resultado = mysql_store_result (conn); 
	resultado = mysql_store_result (conn);
	numero=mysql_num_rows(resultado);
	row = mysql_fetch_row (resultado);
	if (row == NULL)
	{
		printf ("No se han obtenido datos en la consulta\n");
		strcpy(respuesta,"3/1/0");
	}
	else
	{
		if(numero==1)
		{
			printf ("%s ha ganado la partida mas larga\n", row[0] );
			sprintf (nombre,"3/1/1,%s,",row[0]);
		}
		else
		{
			printf ("Hay varias partidas con la duracion mas larga, siendo los ganadores:\n");
			strcpy (nombre,"3/1/2,");
			
			while(i<numero)
			{
				printf("%s ",row[0]);
				sprintf(nombre,"%s, %s",nombre,row[0]);
				row = mysql_fetch_row (resultado);
				i++;
			}
		}
		strcpy(respuesta,nombre);
		
	}
	
	
}

void conn_DDBB(MYSQL **conn) //Establece conexion con la base de datos y lo guarda en la variable conn
{
	//Conector para acceder al servidor de bases de datos 
	int err;
	//Creamos una conexion al servidor MYSQL 
	*conn = mysql_init(NULL);
	if (conn==NULL) {
		printf ("Error al crear la conexion: %u %s\n", 
				mysql_errno(*conn), mysql_error(*conn));
		exit (1);
	}
	
	//inicializar la conexion, indicando nuestras claves de acceso
	// al servidor de bases de datos (user,pass)
	*conn = mysql_real_connect (*conn, "localhost","root", "mysql", NULL, 0, NULL, 0);
	if (conn==NULL)
	{
		printf ("Error al inicializar la conexion: %u %s\n", 
				mysql_errno(*conn), mysql_error(*conn));
		exit (1);
	}
	else
		printf("Conexion con la base de datos realizada.\n");
	//indicamos la base de datos con la que queremos trabajar 
	err=mysql_query(*conn, "use Juego;");
	if (err!=0)
	{
		printf ("Error al crear la base de datos %u %s\n", 
				mysql_errno(*conn), mysql_error(*conn));
		exit (1);
	}
	
	
	
	
}
void crea_conn(int *sock_listen) //Inicialitza l'escolta de noves connexions
{
	
	
	struct sockaddr_in serv_adr;
	// INICIALITZACIONS
	// Obrim el socket
	if ((*sock_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
		printf("Error creant socket");
	// Fem el bind al port
	
	
	memset(&serv_adr, 0, sizeof(serv_adr));// inicialitza a zero serv_addr
	serv_adr.sin_family = AF_INET;
	
	// asocia el socket a cualquiera de las IP de la m?quina. 
	//htonl formatea el numero que recibe al formato necesario
	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
	// escucharemos en el port 9050
	serv_adr.sin_port = htons(9050);
	if (bind(*sock_listen, (struct sockaddr *) &serv_adr, sizeof(serv_adr)) < 0)
		printf ("Error al bind\n\n");
	//La cola de peticiones pendientes no podr? ser superior a 4
	if (listen(*sock_listen, 2) < 0)
		printf("Error en el Listen");
	
}
void *escolta_comanda(Parametres *param)//Funcio de thread. Aqui es produeix la comunicacio amb els clients
{
	
	char buff[512];
	char buff2[512];
	int byebye=0, ret;
	while(byebye==0)
	{
		printf ("Client %d: Escuchando\n", param->num);
		ret=read(param->socket,buff, sizeof(buff));
		printf ("Client %d: Recibido\n", param->num);
		buff[ret]='\0';
		
		//He de saber que volen:
		char *p = strtok( buff, "/");
		int codigo =  atoi (p);
		char query[512];
		
		if(codigo == 0)//Desconectar
		{
			pthread_mutex_lock (&accesoexcluyente);
			int res = EliminarConectado(param->socket,&lista);
			pthread_mutex_unlock (&accesoexcluyente);
			if(res == 0)
			{
				printf("Conectat eliminat\n");
			}
			else
			{
				printf("No s'ha trobat\n");
			}
			close(param->socket);
			printf ("Client %d: Desconectado\n", param->num);
			EnviarNotificacion(&lista);
			byebye=-1;
		}
		else if (codigo ==1)//registro
		{
			int res;
			char nombre[20];
			char contrasena[20];
			p = strtok( NULL, "/");
			strcpy (nombre, p);
			p = strtok( NULL, "/");
			strcpy (contrasena, p);
			printf ("Codigo: %d, Nombre: %s, contrasena: %s\n", codigo, nombre, contrasena);
			pthread_mutex_lock (&accesoexcluyente);
			res = registro(nombre, contrasena, conn,buff2);
			pthread_mutex_unlock (&accesoexcluyente);
			write (param->socket,buff2, strlen(buff2));
			if(res == 0)
			{
				printf("Registre completat");
			}
			else
			{
				printf("No s'ha completat el registre");
			}
		}
		
		else if (codigo ==2)//login
		{
			int err;
			char nombre[20];
			char contrasena[20];
			
			p = strtok( NULL, "/");
			strcpy (nombre, p);
			p = strtok( NULL, "/");
			strcpy (contrasena, p);
			printf ("Codigo: %d, Nombre: %s, contrasena: %s\n", codigo, nombre, contrasena);
			err=login(nombre,contrasena,conn);
			if (err!=0) {
				printf ("Error al consultar datos de la base\n");
				strcpy (buff2,"2/1,");
			}
			else
			{
				char aux[30];
				strcpy(buff2,"2/0,");
				pthread_mutex_lock (&accesoexcluyente);
				AnadirConectado(param->socket, nombre,&lista);
				pthread_mutex_unlock (&accesoexcluyente);
				EnviarNotificacion(&lista);
			}
			
			write (param->socket,buff2, strlen(buff2));
			
		}
		else if(codigo == 3)//consultes
		{
			p = strtok( NULL, "/");
			int codigo2;
			char fecha[80];
			codigo2 =  atoi (p);
			if(codigo2==1)
				frase_marc(conn,buff2);
			else if(codigo2==2)
			{
				char dia[2], mes[2], ano[4];
				p = strtok( NULL, "/");
				strcpy (dia, p);
				p = strtok( NULL, "/");
				strcpy (mes, p);
				p = strtok( NULL, "/");
				strcpy (ano, p);
				sprintf(fecha,"%s", dia);
				strcat(fecha, "/");
				strcat(fecha, mes);
				strcat(fecha, "/");
				strcat(fecha, ano);
				frase_gabri(conn,fecha,buff2);
			}
			else if(codigo2==3)
					frase_jordi(conn,buff2);
			
			else
				printf("Error lleyendo datos\n");
			
			
			write(param->socket,buff2,strlen(buff2));
		}
		else if (codigo==4)//borrar usuario
		{
			char nombre[16];
			p = strtok( NULL, "/");
			strcpy(nombre,p);
			char query[64];
			sprintf(query,"DELETE FROM Usuarios WHERE Usuarios.Username = '%s'", nombre);
			// hacemos la consulta 
			int err=mysql_query (conn, query); 
			if (err!=0) {
				printf ("Error al consultar datos de la base\n");
			}
		}
		
		else if (codigo ==30)//Peticion de crear partida
		{
			int num;
			int sockets[20];
			char invitados[200];
			p = strtok( NULL, "/");
			num=atoi(p);
			p = strtok( NULL, "/");
			strcpy (invitados, p);
			char *p = strtok( invitados, ",");
			sockets[0]=atoi(p);
			int i;
			for(i=1;i<num;i++)
			{
				char *p = strtok( NULL, ",");
				sockets[i]=atoi(p);
			}
			pthread_mutex_lock (&accesoexcluyente);
			int res = Crearpartida(num,sockets,param->socket,&Partidas);
			pthread_mutex_unlock (&accesoexcluyente);
			if(res==-1)
				printf("Se ha alcanzado el n\ufffamero m\uffe0ximo de partidas\n");
			else
				printf("Invitaciones enviadas\n");
		}
		else if (codigo ==31)//Peticion de unirse o no a la partida.
		{
			int IdPart,respuesta, i;
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			p = strtok( NULL, "/");
			respuesta=atoi(p);
			
			pthread_mutex_lock (&accesoexcluyente);
			int res = RespuestaInvitacion(IdPart,respuesta,param->socket,&Partidas);
			pthread_mutex_unlock (&accesoexcluyente);
			if(res==-1)
				printf("Faltan jugadores\n");
			else
			{
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					Partidas.partida[IdPart].identidad[i].muerto=0;
				}
				printf("Partida Empezada\n");
				
			}
			
			
		}
		else if (codigo ==32)//Peticion de envio de mensaje
		{
			int IdPart,respuesta;
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			p = strtok( NULL, "/");
			char mensaje[200];
			strcpy(mensaje,p);
			EnviarMensaje(IdPart,mensaje,&Partidas);	
		}
		else if (codigo ==40)//Jugador desconectado de la partida
		{
			printf("Jugador desconectado\n");
			int IdPart;
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			pthread_mutex_lock (&accesoexcluyente);
			JugadorDesconectado(IdPart,param->socket,&Partidas);
			pthread_mutex_unlock (&accesoexcluyente);
			sprintf(buff2,"40/%d,%d,",IdPart,param->socket);
			int i;
			for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
			{
				write(Partidas.partida[IdPart].identidad[i].socket,buff2,strlen(buff2));
			}
			
		}
		else if(codigo == 50)//Rep els pokemons 
		{
			int IdPart,socket,pokemons[3],i;
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			socket=param->socket;
			for(i=0; i<3 ; i++)
			{
				p = strtok( NULL, "/");
				pokemons[i]=atoi(p);
			}
			int client = BuscarJugador(IdPart, socket, &Partidas);
			Partidas.partida[IdPart].pokemonsTriats++;
			for(i=0;i<3;i++)
			{
				Partidas.partida[IdPart].identidad[client].pokemon[i].id = pokemons[i];
			}
			Partidas.partida[IdPart].identidad[client].pokemonLuchador.id = pokemons[0];
			int var = BuscarPokemon(pokemons[0], listaPokemon);
			Partidas.partida[IdPart].identidad[client].pokemonLuchador.vida = listaPokemon[var].vida;
			
			if(Partidas.partida[IdPart].pokemonsTriats==Partidas.partida[IdPart].jugadores)
			{
				sprintf(buff2,"50/%d,",IdPart);
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					int n;
					for(n=0; n<3;n++)
					{
						sprintf(buff2,"%s%d,",buff2, Partidas.partida[IdPart].identidad[i].pokemon[n].id);
					}
				}
				sprintf(buff2,"%s/",buff2);
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					write(Partidas.partida[IdPart].identidad[i].socket, buff2, strlen(buff2));
				}//Ara que ja te els pokemons, ha de donar ordre que han de triar 
			}
			
		}
		else if(codigo == 51) //INGAME -->51/IdPart/user/accio. Es rebran torns just despres d'haver enviat quins pokemons te cadascu
		{
			int IdPart,user,accio;
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			user = BuscarJugador(IdPart, param->socket, &Partidas);
			p = strtok( NULL, "/");
			accio=atoi(p);
			if(accio==1)//Canvi de pokemon --> 51/IdPart/user/accio/pokemonID
			{
				int pokemonChange;
				p = strtok( NULL, "/");
				pokemonChange=atoi(p);
				Partidas.partida[IdPart].identidad[user].nextAction = 1;
				Partidas.partida[IdPart].identidad[user].nextPokemon = pokemonChange;
				//Partidas.partida[IdPart].identidad[user].pokemonLuchador = pokemonChange;
				//printf("Jugador ha canviado de pokemon");
			}
			if(accio==2)//Atac  ---> 51/IdPart/user/accio/atac/objectiu
			{
				int atac,objectiu;
				p = strtok( NULL, "/");
				atac=atoi(p);
				p = strtok( NULL, "/");
				objectiu=atoi(p);
				Partidas.partida[IdPart].identidad[user].nextAction = 2;
				Partidas.partida[IdPart].identidad[user].nextMovement = atac;
				Partidas.partida[IdPart].identidad[user].nextObjective = BuscarJugador(IdPart, objectiu, &Partidas);
				
				
			}
			Partidas.partida[IdPart].turnoReady++;
			//Quan tothom hagi dit la seva, es podra calcular l'ordre d'atac.
			if(Partidas.partida[IdPart].turnoReady==Partidas.partida[IdPart].jugadores)
			{
				//MECANICA DE CANVIS i ATACS
				char msg[64];
				int vidaExtreta;
				sprintf(msg,"51/%d,",IdPart);
				//CANVIS
				int i;
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					if(Partidas.partida[IdPart].identidad[i].nextAction == 1)
					{
						Partidas.partida[IdPart].identidad[i].pokemonLuchador.id = Partidas.partida[IdPart].identidad[i].nextPokemon;
						printf("Jugador ha canviado de pokemon");
						sprintf(msg,"%s%d,%d,%d,",msg,accio,i,Partidas.partida[IdPart].identidad[i].nextPokemon);
					}
				}
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					if(Partidas.partida[IdPart].identidad[i].nextAction == 2)
					{
						if(Partidas.partida[IdPart].identidad[i].pokemonLuchador.vida!=0)
							vidaExtreta = CalcularDanyo(Partidas.partida[IdPart].identidad[i].pokemonLuchador.id,Partidas.partida[IdPart].identidad[i].nextMovement, Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].pokemonLuchador.id);  //CALCULAR DAÑO AQUI
						else 
						{
							vidaExtreta=0;
							Partidas.partida[IdPart].identidad[i].nextAction = -1;
						}
						if(vidaExtreta >= Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].pokemonLuchador.vida)
						{
							Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].pokemonLuchador.vida =0;
							Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].muerto=1;
						}
						//Si el mata, ha de canviar de pokemon automaticament (jordi)
						else
						   Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].pokemonLuchador.vida=Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].pokemonLuchador.vida-vidaExtreta;
						sprintf(msg,"%s%d,%d,%d,%d,",msg,Partidas.partida[IdPart].identidad[i].nextAction,i,Partidas.partida[IdPart].identidad[i].nextObjective,Partidas.partida[IdPart].identidad[Partidas.partida[IdPart].identidad[i].nextObjective].pokemonLuchador.vida);
					}
				}
				strcat(msg,"/");
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					write(Partidas.partida[IdPart].identidad[i].socket,msg,strlen(msg)); //Enviem el resultat del torn a tots els clients
				}
				printf("Turno enviado");
				int count=0;
				for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
				{
					if(Partidas.partida[IdPart].identidad[i].muerto==1)
						count++;
				}
				if(count == Partidas.partida[IdPart].jugadores-1)
				{
					int guanyador;
					char nom[32];
					for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
					{
						if(Partidas.partida[IdPart].identidad[i].muerto==0)
							guanyador = Partidas.partida[IdPart].identidad[i].socket;
					}
					BuscarConectado(nom, guanyador, &lista);
					Afegirvictoria(nom,conn);
				}
				Partidas.partida[IdPart].turnoReady=0;
			}
		}
		else if(codigo==52) // 52/IdPart/idpokemon, no implementat a la versio final
		{
			//El jugador amb pokemon mort envia un missatge dient quin pokemon treu ara:
			int IdPart,idPok, user, temp, i;
			char msg[32];
			sprintf(msg,"52/%d,",IdPart);
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			p = strtok( NULL, "/");
			idPok = atoi(p);
			user = BuscarJugador(IdPart, param->socket, &Partidas);
			Partidas.partida[IdPart].identidad[user].pokemonLuchador.id = idPok;
			int var = BuscarPokemon(idPok, listaPokemon);
			Partidas.partida[IdPart].identidad[user].pokemonLuchador.vida = listaPokemon[var].vida;
			printf("Jugador ha canviado de pokemon");
			sprintf(msg,"%s%d,%d/",msg, user, Partidas.partida[IdPart].identidad[user].pokemonLuchador.id);
			for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
			{
				write(Partidas.partida[IdPart].identidad[i].socket, buff2, strlen(buff2));
			}
			
		}
		else if (codigo ==55)//Set del fons de partida. Tan sols es dedica a copiar el missatge i reenviar a tots els jugadors de la partida.
		{
			int IdPart,fons;
			p = strtok( NULL, "/");
			IdPart=atoi(p);
			p = strtok( NULL, "/");
			fons = atoi(p);
			char fondo[32];
			sprintf(fondo,"55/%d,%d",IdPart, fons);
			int i;
			for(i=0;i<Partidas.partida[IdPart].jugadores;i++)
			{
				write(Partidas.partida[IdPart].identidad[i].socket, fondo, strlen(fondo));
			}//Ara que ja te els pokemons, ha de donar ordre que han de triar 	
		}
		else
				 printf("Error lleyendo datos\n");
	}
	close(param->socket);
}

int main(int argc, char *argv[])
{
	char respuesta[512];
	Parametres param[100];
	pthread_t thread[100];
	pthread_mutex_init(&accesoexcluyente, NULL);
	lista.longitud=0;
	conn_DDBB(&conn);
	int sock_conn, sock_listen, i=0;
	crea_conn(&sock_listen);
	cargar_pokemons(conn,listaPokemon);
	cargar_movimientos(conn,listaMovimientos);
	//Ara que ja esta tot carregat, es moment d'escoltar i iniciar nous threads per cada nova connexió.
	for(;;){
		printf ("Escuchando\n");
		sock_conn = accept(sock_listen, NULL, NULL);
		param[i].socket = sock_conn;
		param[i].num = i;
		printf ("He recibido conexi?n\n");
		pthread_create(&thread[i],NULL,(void *)escolta_comanda,&param[i]);
		i++;
	}
	mysql_close (conn);
	pthread_mutex_destroy(&accesoexcluyente);
	printf("Servidor CERRRADO");
	return 0;
}




